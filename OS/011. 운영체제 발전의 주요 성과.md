# 운영체제 발전 과정에서 이뤄진 주요 성과들

## 1. 프로세스에 대한 개념이 등장

### 프로세스란?

> 프로세스(process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰인다. <프로세스>, 위키백과.

즉, 우리가 실생활에서 윈도우 같은 운영체제를 통하여하나의 프로그램을 실행하면, 그것이 바로 하나의 프로세스임.

프로세스라는 용어가 사용되기 이전에는, 1960년대 "Job"이라는 용어가 Multics라는 운영체제가 설계될 때 처음 사용되었다. 프로세스는 이후 Job에 여러 다른 개념들이 추가적으로 들어간 개념으로 보면 좋다.

프로세스는 네 가지 측면으로 정의해볼 수 있다. 

  * 컴퓨터에서 실행중인 프로그램

  * 컴퓨터에서 실행중인 프로그램의 한 인스턴스(메모리, 처리기를 점유하는 object로서)

  * 처리기에 할당되어 수행될 수 있는 개체 (처리기가 실행할 수 있는 어떤 것)

  * "**쓰레드**"라는 개념이 등장하기 이전, 하나의 프로세스 내에 있는 쓰레드(프로세스를 실행하는 주체)도 프로세스라고 불렸다. 
    ** 프로세스가 생겨난 초기에는 쓰레드라는 개념이 없었고 그냥 오늘날의 쓰레드가 프로세스로 받아들여졌었다. 쓰레드라는 용어가 생기고 나서 프로그램 내에서 병렬적으로 수행되는 주체를 쓰레드라고 부르기 시작한 것이다.
    
    > 웹 브라우저(프로그램이자 프로세스)를 띄우는 상황을 예로 들 수 있다. 브라우저를 실행시키면, 브라우저에서는 여러 실행 단위들이 병렬적으로 실행되고 있는 것이다. 그 이유로 어떤 웹 사이트에 접속하게 되면, 준비가 완료된 부분을 먼저 볼 수 있게 되며, 이는 기다리는 사용자의 답답함을 어느 정도 해소시킨다 볼 수 있다. 이 과정에서 **프로세스 내에서 병렬적으로 수행되고 있는 실행 단위들**이 바로 **쓰레드**이다. 

서로 다른 A, B프로세스가 있다고 하면,
A 프로세스 내에서 프로그램이 실행될 때 A 프로세스 내에 있는 메모리에 엑세스할텐데, 만약 또 다른 B프로세스가 실행중일 때, A 프로세스에서 B 프로세스의 메모리로 접근하는 일이 일어난다면, 보안에 문제가 생김. 또한 A프로세스의 오동작으로 인하여 B프로세스도 영향을 받게 됨. 이런 것들은 B번 프로세스 입장에서 자기는 문제가 없지만 다른 프로세스가 오동작하는 바람에 자기도 영향을 받으면 곤란... 따라서 프로세스는 자기 자신의 메모리에서 벗어나서 다른 영역을 접근하는 것을 금지시킴. 그럼 어떠한 방식으로 일어나냐? 앞서 말한 일이 일어나려고 할 때, 운영체제는 즉시 그 프로세스를 ‘없애’버린다.(Kill) -> 프로세스라는 개념이 등장하면서 이 개념도 생김.

주요 컴퓨터 시스템 계열
멀티프로그래밍 일괄처리 -> 시분할 -> 실시간 트랜잭션(데이터베이스 질의같은 것들을 처리하는, 실시간 트랜잭션을 처리하는 컴퓨팅 시스템)...

타이밍과 동기화문제가 프로세스 개념 탄생에 기여하였다.
운영체제에서는 타이밍, 동기화문제 존재
1.타이밍
- 시분할 시스템 운영체제의 등장으로, 시간을 일정하게 쪼개어 번갈아 실행되어야 하는 여러 실행 주체(인스턴스)라는 개념을 만들어야 했음. 그것이 프로세스라는 개념이 탄생한 동기 중 하나
2. 동기화문제
- 두개의 실행 주체가 동시에 실행되고 있을 때, 어떤 메모리/디스크/네트워크 등 컴퓨터 자원을 서로 공유하고 있는 상황에서, 이 자원을 한 실행 주체가 읽고 있을 때, 다른 주체가 쓴다거나 하는 상황이 일어난다면, 어떤 순서대로 작업이 이뤄져야 하는지가 중요함. 예를 들면 수정하고 있는 동안에 읽게 되면 곤란함... 그런 동기화 문제를 해결해야 했음. 동기화문제를 해결하기 위해 공유된 자원에 접근하는 주체들이 무엇인가에 대한 개념이 필요했음. 그 개념으로 프로세스라는 개념이 탄생하게 됨.

프로세스 별로 시간을 쪼개어 실시간으로 데이터를 처리하게 되면(시분할 시스템), 응답 시간이 빨라짐. 시분할 시스템에서는 빠른 응답시간을 제공해주는 것이 중요한 문제. 유저가 키보드를 타이핑하면, 즉시 컴퓨터가 반응을 해주어야 함. 그렇게 하기 위해서는 프로세스라는 개념이 필요했음..

그렇게 여러 개의 프로세스가 실행을 하다 보니, 에러가 발생하면 그 에러의 원인이 어떤 프로세스에 있는지 파악하기가 어려움. 이러한 에러의 주요 원인으로는
i. 부적절한 동기화(서로 공유하고 있는 자원을 사용할 때에는 프로세스들이 순서를 잘 지켜 사용해야 하고, 변경 도중에 읽으면 안되는 등 규칙들을 지켜야 하는데, 이러한 동기화가 잘 되지 않을 때- 부적절한 동기화가 발생할 때 오류가 생김)
ii. 동기화를 시키기 위해 우리가 어떤 것을 이용하냐 하면, lock같은 것을 이용하여 상호배제를 함. 상호배제란 프로세스A가 공유자원 P를 접근할 때에는 B 또는 C프로세스 같은 다른 프로세스들이 공유자원 P로 접근하지 못하도록 하는 것. 공유자원에 대해 상호 배제가 잘 이뤄져야 하는데, 이것들이 잘 안되는 경우 에러가 일어남.
iii. 비결정적인 프로그램 연산 : 어떤 동일한 메모리를 공유하고 있을 때, 다른 프로그램이 갑자기 그 공유메모리에 엉뚱한 값을 써서(write) 한 프로그램에 영향을 받으면, 그 프로그램은 실행할 때마다 어떻게 진행될지 잘 모를 것. 그렇기 때문에 비결정적임...
iv. 공유자원을 처리할 때(상호배제를 하기 위해 상호배제하는 메커니즘을 잘 이용해야 함-lock), lock을 걸고 풀고 함. 그럴 때, 프로그램들이 서로 lock을 물고 있는 상태. 그것이 바로 교착상태임. 이 교착상태(deadlock)이 일어나면 더 이상 진행이 되지 않고 오류가 생김

프로세스의 구성 요소
- 하나의 프로그램이 곧 프로세스라고 했음. 메모리에 올라온 수행 가능한 프로그램이 프로세스의 한 구성 요소임.
- 프로그램을 실행하다 보면, 프로그램이 데이터가 필요함. 그 프로그램이 필요로 하는 데이터
- 한 프로그램이 실행될 때, 시분할 시스템에 의해 다른 프로그램이 실행될 수 있음. 다른 프로그램이 실행되다가 다시 그 프로그램으로 돌아왔을 때, 실행이 중단되었던 지점부터 다시 실행해야 할 것임. 이 때, 중단되지 않고 끝까지 프로그램이 실행되는 과정과 중간에 끊겼다가 다시 실행되는 그 과정은 그 실행결과가 서로 같아야 할 것임. 중단되었던 프로그램이 다시 실행될 때, 원래 상태를 유지하기 위해서는 그 프로그램의 여러 가지 상태정보들을 가지고 있어야 함. 그것이 바로 프로그램의 수행 문맥임.

+추가설명 - 수행 문맥(execution context)
process state(프로세스 상태 정보)
- 프로세스를 감독하고 제어하기 위한 내부적인 데이터
- 수행 문맥을 이용해서 프로세스의 주소 공간을 서로서로 분리하는 데 사용. 예를 들어, process A가 있고, process B가 있다고 하면, 각각의 프로세스에는 아까 언급한 대로 프로그램, 데이터 그리고 문맥으로 하나의 프로세스를 이룸. 그러면 어떤 프로세스가 실행될 때, cpu내에는 여러 레지스터들이 있음. (process index : 몇 번 프로세스가 실행중인지 알려주는 레지스터, pc, base : base register에 저장된 주소는 바로 프로세스의 ‘시작되는’주소, limit: 프로세스 메모리의 크기(h), 등이 있음)

만약 어떤 프로세스(프로그램)가 실행이 되다가, 어떤 곳에서 타임 슬롯(할당된 시간)이 끝나 중단되고 다른 프로세스가 실행되어야 할텐데, 이것을 바로 문맥 교환(한 context에서 다른 context로 switch)이라고 함. 만약 A프로세스에서 문맥 교환이 일어난다면 멈추고 B프로세스가 실행될 것임. 그리고 B프로세스가 실행되고 타임 슬롯이 끝나 중단되고 A프로세스가 멈춘 지점부터 다시 실행되려고 할 때(문맥교환), 이 레지스터의 값은 바뀌어있을 것임. 왜냐하면 B프로세스가 실행되고 있을 때, B는 레지스터의 값을 막 변경하며 cpu를 사용하고 있었을 것임. 문맥교환 없이 A프로세스가 다시 실행된다면, 실행 결과는 A프로세스가 중단 없이 실행된 결과와는 다를 것임. 그러면 안됨. 그렇기 때문에, A프로그램 실행 당시 cpu에 들어있던 레지스터의 정보들을 잘 어디에 저장했다가 문맥 교환이 일어났을 때 복구하는 과정이 필요함. 그렇기 때문에 한 프로그램 실행 중 다른 프로그램이 실행될 때, 프로세스 내에 context라는 메모리에 그 프로세스의 상태 정보(당시 cpu의 레지스터의 값들)을 잘 두었다가, 다시 문맥 교환이 일어나면 프로그램에 저장해 두었던 context(레지스터 값들)를 cpu에 복구한 다음에 이어서 실행. 이렇게 해야 연속된 동작이 보장됨.

- 쓰레드라는 것은 프로세스 내의 여러개의 실행흐름임. 

## 2. 메모리 관리에 대한 진전

어떤 프로세스(프로그램) A, B가 있다고 가정. A프로세스의 메모리를 연속적으로 이어져 있는 것처럼 하나로 관리하지 않고, 적절한 단위 크기로 (보통 4kb단위로)나눔. 이 잘린 하나의 단위를 page 또는 block이라고 부름. 디스크에 저장되어 있는, 4kb짜리 페이지로 나눈 단위가 실행되도록 하기 위해서는 그 페이지를 메인메모리에 적재해야 할 것임. 이 때, 이 메모리를 잘 활용하기 위해서, 메모리에 있는 블록 공간들 중 임의의 블럭 위치에 갖다둠. (디스크에는 있어도 메인메모리에는 없을 수도 있음.) 프로그램 b도 마찬가지로 분리배치

그러면, 여기 있는 메모리에 프로그램이(a1, a2, a3,,,,) 물리적으로는 흩어져있음. 그러나 논리적으로는 각각의 프로세스는 연속된 메모리에 있는 것임. 논리주소와 물리주소의 개념이 있음. 논리주소는 가상메모리라고 부름. 이 가상주소를 물리적주소로 변환하는 매커니즘이 바로 가상메모리주소지정매커니즘임. 이것을 정확히는 메모리관리유닛이 처리기와 주기억장치에 위치하여 주소변환을 해줌.
그림 2.10에서, 프로세스는 가상주소로 접근하게 되면, 메모리 관리 모듈(유닛)이 가상주소를 물리주소(메인메모리의 주소)로 바꿔 가져옴.  
메인메모리에 있는 각 공간은 디스크보다 상당히 작음. 그래서 메모리의 일부는 물리메모리에 있고, 또 메모리의 일부는 물리메모리에 없고 디스크에 그냥 유지하도록 함. 이것을 스왑 메모리라고 부름. 가상메모리로 가리킬 수 있는 메모리는 전체적으로 보면 실제 램에 있는 물리적 메모리와 디스크에 있는 메모리를 합친 것이 가상메모리 주소가 됨.(나중에 더 자세히)

각각의 virtual address는 주소가 어떻게 지정되는가? 가상메모리는 물리적 메모리와 디스크를 합한 메모리라고 했음. 하나의 프로그램이 있다고 하면, 논리적으로 0번부터 n번까지 차례대로 주소가 부여됨. 논리적으로 사용하고 있는 그 주소가 가상메모리주소임. 그 주소를 가지고 cpu는 메모리로 접근하는데, 중간에 메모리 관리 유닛이 이 가상주소를 실질적인 메모리로 바꿈. 예를 들면 메인메모리에 있다면 메인메모리 주소로 바꾸고, 일부가 디스크에 있으면 디스크의 주소로 바꿈. 이럴 때, 디스크를 파일과 구분해야 함. 디스크에는 파일도 있지만, 메인메모리를 디스크에 유지하는 스왑이라는 영역도 있음. 
-정리 : 디스크의 일부 공간을 메모리처럼 사용하는 영역을 두고, 그 부분을 스왑이라고 함. 스왑과 메인메모리ram를 합한 메모리가 컴퓨터의 전체 메모리가 됨. 프로세스는 전부 0번지부터 시작하는 virtual address로 주소가 지정되고, 그 가상 주소가 실질적 주소로 바뀌어 연산이 실행됨. 이렇게 되면, 하나의 프로세스에서 다른 프로세스의 메모리로 접근할 수 없음. 왜냐하면 프로세스 내에서의 주소는 가상주소로 접근함. 가상 주소라는 것은 자기 영역 내에서 접근한다는 수단임. 프로세스 영역에서 벗어나기 위해서는 없는 가상주소로 접근하는 방법이 있는데(100번지까지 있는데 105번/-5번으로 접근하는 등 프로세스 크기보다 더 큰 영역, 음수영역으로) 그렇게 하면, 그 프로세스의 실행을 강제로 중지시킴. 프로세스가 메모리에서 프로세스 별로 분리가 되는 효과가 있음. 물리적 메모리나 디스크(보조기억장치)에 있는 스왑메모리를 관리해야 하는데, 만약 이것을 갖다가 연속적 메모리(132byte)와 같은 식으로 메모리 할당을 하게 되면, 자원의 효율적 관리가 어려움. 따라서 ram/disk/swap memory 전부 페이지 크기로 나누어 페이지들을 할당하는 식으로 관리를 함. 
그러니, 운영체제는 프로그램을 페이지 단위로 관리하기에 메모리가 효율적으로 사용되고, 운영체제가 가상주소와 물리적 주소와 서로 맵핑(디스크에 있는 쪼개진 유저프로그램의 물리주소를 정해주는 일인 맵핑은 운영체제의 역할)을 하기 때문에 이것들이 메인메모리에서 공간이 프로세스별로 연속될 필요가 없음.(자동할당 및 관리에 대한 설명)

-모듈식 프로그래밍 지원
 모듈식 프로그램을 지원. 프로그래머는 프로그램 모듈(전체가 아닌 일부분)을 메모리에 올렸다 내렸다 할 수 있어야 함. 운영체제가 이것을 가능하게 해줌.

-메모리는 여러개의 프로세스가 공유할 수 있음.
프로세스를 분리한다는 것은 메모리를 배타적으로 사용한다는 것임. 어떤 특정 메모리를 프로세스 a,b가 같이(동시x) 한 메모리를 사용하게 할 수 있음. 이것을 공유메모리라고 이야기함. 그럴 때, 그 메모리를 공유하고 있을 때에 문제가 없도록 하기 위해서는 한 프로세스가 변경하고 있는 도중에는 다른 프로세스가 그 메모리로 접근하면 안되고 끝날 때까지 기다리도록 해야 할 것임. 메모리를 보호하거나 접근을 제어할 수 있도록 운영체제가 역할을 해야함.

- 응용프로그램은 종료가 되었을 때에도 데이터가 오랫동안 유지될 수 있도록 해야함. 필요한 내용은 전원이 꺼져도 데이터가 유지되는 디스크와 같은 저장장치를 이용하여 데이터가 계속 유지되도록 하는 기능을 운영체제가 제공해야 함.

## 3. 정보보호 및 보안

보안기법들이 적용되어 운영체제가 관리되도록 해야 함. 
시스템 보안을 하는 이유는 
- 가용성 : 시스템이 중지되지 않도록...(누군가가 침입하여 엉뚱한 행동을 하여 시스템이 망가지지 않도록) 하고, 
- 기밀성 : 권한이 있는 사람만 데이터를 읽을 수 있도록 해야함. 데이터 내에서 권한 정보를 부여했다가 권한이 없는 사용자가 데이터를 읽는 행위를 못하도록. (예를 들면 암호화.. 강제로 디스크를 물리적으로 떼서 다른 컴퓨터에서 실행한다고 해도 생각대로 데이터를 읽을 수 없도록 하는 방법...)
- 데이터 무결성 : 데이터가 불법적으로 수정되지 못하도록 보호. 데이터의 보안을 유지하여 권한 없는 사람이 데이터 변경하는 것을 금지
- 신빙성 : 이런 것들을 다 하기 위해 사용자의 아이디 pw등으로 신원검증, 각각의 데이터 권한 정보를 유지하여 권한 없는 사람이 데이터 접근 못하도록 하는 매커니즘을 운영체제가 제공

## 4. 스케줄링, 자원관리 발전

운영체제에서 프로세스들이 동시에 실행될 때, 어떤 프로세스를 실행했다가 다시 다른 프로세스로 실행하는 프로세스 실행 순서를 어떻게 결정하는가?에 관함.
프로세스 a가 실행되었다가 b가 실행되는 어떤 순서를 갖다가 프로세스 스케줄링이라고 함.
프로세스 스케줄링을 할 때, 스케줄링을 어떻게 하느냐에 따라 여러 정책이 있음. 

스케줄링 정책을 결정하는데 중요한 요소 세가지 : 
- 공정성 : 각각의 프로세스가 특정 자원을 서로 빨리 점유하려고 경쟁할 때(디스크, 메모리, I/o장치 등) 여러 프로세스에 공정하게 시스템 자원을 분배해야 함), 
- 반응시간 차등화(반응시간 : 어떤 프로세스가 실행되었다가 유저에게 결과를 알려주는 시간/서비스를 요청했다가 서비스가 끝나는 시간): 상황에 따라 어떤 것을 빠르게 반응해야 할 것이고, 어떤 것은 느리게 반응해도 되는 것이 있음. 그런 것들을 차등화할 수 있어야 함. 이것들이 스케줄링 정책에 영향을 미칠 것임.
- 효율성 : 주어진 시간에 최대한 많은 양을 실행하고, 최대한 많은 수의 사용자들을 허용해야 할 것임. 효율적으로 동작해야함.

그림 2.11에서 운영체제가 여러 가지 정책을 수행하면서 실행되고 있을 때,
여러개의 프로세스가 I/O를 요청하면, 여러 각각의 프로세스는 I/O를 요청한다는 사실을 운영체제에 요청. 운영체제는 그 요청들(request)을 I/O queue에 저장. 그러면 각 요청들은 queue에 쌓이게 될 것임. queue는 선입선출방식으로, 요청들을 들어온 순서대로 차례로 큐에서 끄집어내어 서비스를 해주는 식으로 동작함. - round-robin정책으로 실행됨.
* 운영체제는 그러한 요청들을 처리하기 위해서 요청들을 저장하고 있는 여러 가지 종류의 큐를 가지고 있음. 예를 들면 롱텀큐(요청을 장기간 기다려야 하는 것)/숏텀큐(요청을 단기간 기다려야 하는 것)

예를 들어보면, 한 프로세스가 실행 중 read요청을 함. 그러면 운영체제는 해당 작업을 큐에 집어넣음. 운영체제는 큐에서 요청을 하나씩 끄집어내어 처리하는데, 그렇게 프로세스에서 요청한 read작업이 처리했다고 하면, 요청한 때부터 그때까지 프로세스는 멈춰있게 될 것임. read가 끝나고, 프로세스는 멈춘 그 지점부터 다시 실행되어야 할 것임. context switch. 사용자가 read요청을 하면 인터럽트를 거는 방식으로 동작될 수 있음
-> 스케줄링에 인터럽트 이용 가능

혹은 요청을 처리한 후에 인터럽트가 발생할 때에, 운영체제가 인터럽트를 처리하는 곳으로 갈 것임. 가서 그곳에서 요청을 했던 프로세스가 무엇인지 찾아 그 프로세스를 계속 실행시키는 작업을 인터럽트 핸들러에서 함.

유저 프로그램이 운영체제에게 I/O를 요청하는 것이 있을 때, 이러한 요청은 모두 시스템 콜로 요청하도록 되어있음. 시스템 콜 함수가 바로 운영체제로 진입하는 함수가 됨.
