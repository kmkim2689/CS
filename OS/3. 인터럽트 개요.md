# 인터럽트 

## Intro

> "마이크로프로세서에서 인터럽트(interrupt), 끼어듦, 또는 가로막기란, 마이크로프로세서(CPU)가 프로그램을 실행하고있을 때, **입출력 하드웨어등의 장치에 예외상황이 발생**하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다." 
> 
> <인터럽트>, 위키백과

처리기는 명령어를 적재된 순서대로 처리한다. 하지만 CPU의 속도 및 효율 향상이 필요하거나 특정 순간에 특정 작업을 해야하는 등 필요에 따라 명령어가 중간에 끼어들어 실행되기도 한다. 이러한 모습은 바로 **인터럽트**라는 기법과 관련이 있다.

*****
> 예시 (생각해보기)
> 
  처리기가 입출력 하드웨어 중 하나인 하드디스크에 입력을 하는 상황에 대해 생각해보자. 처리기의 속도는 1GHz로, 1초에 10^9개의 명령어를 수행할 수 있을 만큼 매우 빠르다. 반면, 하드디스크는 1개의 명령어를 수행하는 데 보통 1/100초의 시간이 소요된다. 
  
  쉽게 생각해보면, **같은 시간(1/100초)동안 처리기가 10^7개의 명령어를 수행하는데, 하드디스크는 1개만 수행**할 수 있다는 것이다. 이렇게 처리기와 하드디스크 간 속도 차는 어마어마하다.
  
  이러한 조건 하에서 이미 알아본 바가 있는 [명령어 사이클 기법](https://github.com/kmkim2689/CS/blob/main/OS/%EB%AA%85%EB%A0%B9%EC%96%B4%20%EC%82%AC%EC%9D%B4%ED%81%B4.md)대로 I/O가 이뤄진다면 어떤 문제점이 발생하는가?
*****

<br/>

   CPU의 관점에서 하드디스크가 처리하는 속도는 매우 느리다. 두 장치 간 속도 차이가 크기 때문에, 처리기가 한 번 입력을 실시하면 처리기에 비해 매우 느린 하드디스크가 처리를 완료할 때까지 **처리기는 다른 작업을 하지 못하게 되는 상태**에 빠지게 된다. 이러한 중단 시간 동안, CPU는 명령어를 수행하지 못하기 때문에 본래 수행할 수 있는 명령어 수만큼 온전히 수행하지 못하는 **비효율**이 발생하게 되는 것이다.
   
   이러한 문제를 어느 정도 해소해주는 것이 바로 **인터럽트**이다. (위의 예시는 앞으로 설명할 인터럽트 종류 중 **입출력 인터럽트**와 관련있다.)
   
<br/>

## 인터럽트의 종류

 * **프로그램** : 프로그램 실행 중, 프로그램이 더 이상 진행될 수 없도록 하는 연산이 발생할 수 있다. 이 경우 프로그램을 종료하도록 하기 위해 인터럽트를 발생시킨다.
 
   > 예) 산술연산을 할 때 오버플로가 생기는 경우, 0으로 나누는 경우, 불법적 기계 명령어 수행 시도 등
   
 * **타이머** : 처리기 내 타이머가 주기적으로 인터럽트를 발생시킨다. 운영체제가 특정 기능을 **정규적**으로 수행할 수 있도록 한다.
 
   > 컴퓨터는 굉장히 짧은 시간동안 번갈아가면서 여러 프로그램을 수행하기 때문에('운영체제의 개요'의 **시분할 시스템**과 관련) 인간이 보기에는 마치 세 개의 프로그램이 동시에 실행되는 것처럼 보인다.
   > 
   > 이러한 기법을 구현하기 위해서는, 약속한 시간이 되면 다른 프로그램으로 넘어가도록 해주는 것이 필요하다. 이것을 위해 타이머 인터럽트를 발생시키며, 인터럽트를 처리하는 운영체제 모듈에서 문맥 교환이 이뤄지는 방식으로 수행되는 프로그램이 끊임없이 변경된다.
   > 
   > 세 개의 프로그램 A, B, C가 수행되는 상황을 생각해볼 수 있다. 수행되는 순서는 A - B - C라고 가정해본다. 타이머 인터럽트에 의하여 A프로그램이 실행되다가 일정 시간이 지나면 B프로그램이 실행되고, 또 일정 시간이 지나면 C프로그램이 실행된다. 그러고 나서, 다시 A프로그램이 일정시간 수행되고, B, C순서대로 차례대로 일정시간 동안 수행되는 것을 반복하게 된다.

 * **입출력** : 입출력 연산의 정상적인 종료 혹은 에러를 알리는 인터럽트이다.
 
   > 어떤 프로그램이 실행되다가 프린트, 디스크 읽기 등의 입출력이 요청될 경우, 입출력이 끝날 때까지 프로그램이 계속 멈춰있게 된다면, 처리기는 매우 비효율적으로 사용되는 것이라 볼 수 있다.
   > 
   > 이러한 비효율을 해결하고 컴퓨터를 효율적으로 사용하기 위해, 입출력을 실행하는 동안에는 처리기가 입출력 장치의 속도에 상관 없이 계속 다른 연산을 할 수 있도록 해야 한다. 그리고 입출력 작업이 끝나거나 오류 발생 시, 비로소 입출력 장치가 프로그램에 입출력 인터럽트를 걸어 후작업을 수행하도록 한다.

 * **하드웨어 실패** : 하드웨어에 고장 등 이상이 생겼을 때에도 인터럽트를 걸어준다. 정상 동작할 수 없을 때의 루틴으로 유도하는 방식으로 이뤄진다.

   > 예) 전원결함, 메모리 패러티 에러 등

<br/>

## 인터럽트를 고려한 명령어 사이클

[명령어 사이클 기법](https://github.com/kmkim2689/CS/blob/main/OS/%EB%AA%85%EB%A0%B9%EC%96%B4%20%EC%82%AC%EC%9D%B4%ED%81%B4.md)에 따르면, 명령어를 수행하는 과정은 다음과 같다.

*****
  > 명령어 사이클(2단계 구조)

  1. **시작** : CPU가 가동되며 프로그램의 수행 시작.
  2. **반입** : 프로그램을 구성하는 명령어 하나가 CPU로 반입됨.
  3. **수행** : CPU로 반입한 명령어를 수행.
  
    < 2 ~ 3을 반복적으로 수행하며 프로그램을 실행 >
  
  4. **정지** : 전원 꺼짐 / 오류발생 / 정지명령어 수행 등으로 프로그램 수행 중단.

*****

인터럽트를 고려해보면, 두 가지 상황을 생각해볼 수 있다.

  * 인터럽트가 허용되지 않은 상황 : 인터럽트 금지 시, 위의 사이클과 동일한 과정을 수행한다.
  
  * 인터럽트가 허용된 상황 : **반입과정과 수행과정 사이**에서 위의 [네 가지 이유들](https://github.com/kmkim2689/CS/blob/main/OS/3.%20%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8.md#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%A2%85%EB%A5%98)로 인터럽트가 발생했다면, 인터럽트 요청 신호가 발생하게 된다. CPU는 명령어 수행을 마친 후 인터럽트 신호가 있음을 확인하게 되고, 인터럽트 처리기를 구동하여 인터럽트 처리 루틴을 수행한다. 인터럽트 처리를 마치면, 다시 다음 명령을 수행하도록 한다(다시 2~3의 과정 반복).
  
<br/>

  이 과정에서 중요한 것은, 인터럽트의 발생 여부에 관계 없이 **사용자 프로그램은 인터럽트의 영향을 받지 않도록** 해야 한다는 것이다. 
  
  즉 프로그램은 실행 중 어느 순간에나 인터럽트가 끼어들어도 괜찮도록, 원래 연속적 코드로 실행된 것처럼 동작해야한다. 인터럽트가 일어날 시 원래 처리기 내부의 여러 레지스터들에 있는 값들이 잘 저장되어 있다가 인터럽트가 끝난 후 다시 처리기에 잘 복구되어야 할 것이다. 이것에 대한 내용을 4. 인터럽트 처리에서 알아볼 것이다.
  
## 출처 및 참고
* 학교 수업 내용
* William Stallings 저(전광일 등 역), 운영체제-내부구조 및 설계원리 제8판, 프로텍미디어.
* "인터럽트",『위키백과』.
